# ZJU-blockchain-course-2024-ZJL

## 如何运行

1. 在本地启动ganache应用。

2. 在 `./contracts` 中安装需要的依赖，运行如下的命令：
    ```bash
    npm install
    ```

3. 在 `./contracts` 中编译合约，运行如下的命令：
    ```bash
    npx hardhat compile
    ```

4. 在 `./comtracts` 中部署合约，运行如下命令
    ```bash
    npx hardhat run ./scripts/deploy.ts --network ganache
    ```

5. 将部署得到的地址修改到前端 `src/utils/contract-addresses.json` 文件中

    ```bash
    $ npx hardhat run .\scripts\deploy.ts --network ganache
    BuyMyRoom deployed to 0x16e8d88c03c4e63Fee6Ef40B88718D77a0696925
    erc20 contract has been deployed successfully in 0x45C00bd441E061333C81a7A3044829cB20381B6f
    ```

    ![image-20241013183612876](photos/image-20241013183612876.png)

6. 在 `./frontend` 中安装需要的依赖，运行如下的命令：
    ```bash
    npm install
    ```

7. 在 `./frontend` 中启动前端程序，运行如下的命令：
    ```bash
    npm run start
    ```

## 功能实现分析

1. 首次登录时可以领取3个房屋

​	项目中使用了数据结构 `mapping(address => bool) public hasClaimedHouses` 来记录每个用户是否已经领取过房子，如果用户还没有领取房子，那么对应地址的 boolean 值为 false，如果用户已经领取了房子，那么对应地址的 boolean 值为 true。

​	同时在项目中添加了函数 `airdropHouses()`，当用户登录之后，就可以通过点击领取房子按钮来领取自己的免费房子。在这个函数中，首先会判断发出请求的用户是否已经领取过房子，也就是上面那个数据结构中对应地址的 boolean 值是否为 false，如果用户已经领取过房子，那么就不会再次发放，如果用户还没有领取过房子，那么此时系统便会发放免费的三个房子，并且标记这个用户已经领取过房子。

2. 查看自己拥有的房屋

​	项目中添加了函数 `getUserHouses(address user)`，在这个函数中，系统首先查询了这个用户拥有的房子的数量，然后创建了一个对应大小的数组，接着去遍历所有的房子，判断哪些房子是属于这个用户的，如果遍历到的房子是这个用户的，那么就将这个房子添加到数组中，遍历完所有的房子之后将数组进行返回。

​	在前端页面中，用户在登录之后会有一个查询自己拥有房屋的按钮，点击后便会调用这个函数，在页面中渲染出自己拥有的所有房屋。

3. 使用以太币兑换ERC20代币

​	项目中添加了 ERC20 合约的继承类 `MyERC20`，并且添加了用以太币兑换 ERC20 代币的函数 `buyTokens()`，在这个函数中，首先会判断用户拥有的以太币数量是否足够兑换自己想要的数量，然后通过 `mint()` 函数将对应数量的 ERC20 代币发放到对应用户的账户中，并且同时扣除用户对应数量的以太币。

​	在前端页面中，有一个兑换 ERC20 代币的按钮，点击按钮之后会跳出一个表单，在表单中可以输入自己想要兑换成 ERC20 代币的以太币的数量，再次点击确定后就会调用后端的函数实现 ERC20 代币的兑换。

4. 挂出房屋

​	项目中添加了函数 `listHouse(uint256 tokenId, uint256 price)`，其中的两个参数分别是房屋的编号以及挂出的价格。在这个函数 中，首先会判断这个房屋是不是属于这个想要挂出房屋的用户，然后判断这个房屋是否已经在挂出的市场中。如果这些都没有问题，那么就设置这个房屋的挂出价格，同时标记这个房屋为已挂出，并且更新挂出的时间戳。

​	在前端页面中，用户登录后可以在挂出房屋的表单中输入想要挂出房屋的编号以及价格，然后点击确定，这样就会调用后端的函数实现房屋的挂出。

5. 查看所有挂出的房屋

​	项目中有一个变量 `nextTokenId`，表示下一个免费发放的房屋的编号，用这个变量减去1就是目前所有的房屋的数量。项目中同时添加了函数 `getHousesForSale()`，在这个函数中，首先会对所有的房屋进行遍历，并且用一个变量来记录所有在挂出市场上的房屋的数量。在第一轮遍历结束之后，创建一个大小为挂出房屋总数量的数组，然后再次对所有的房屋进行遍历，如果房屋被挂出，那么就将它添加到数组中，第二轮遍历结束后返回数组。

​	在前端页面中，有一个查询所有挂出房屋的按钮，点击按钮就会调用后端函数，查询所有挂出的房屋，并且展示在前端页面中。

6. 查看房屋拥有者

​	项目中添加了函数 `getHouseOwner(uint256 tokenId)`，传入参数为房屋的编号，这个函数会直接查询所有房屋数组中对应下标的房屋的主人，并且返回给前端。

​	在前端页面中，查询所有挂出房屋后，每个挂出的房屋后面会有一个查询房屋主人的按钮，点击之后便会显示房屋的主人。

7. 查看挂出房屋信息

​	项目中添加了函数 `getHouseInfo(uint256 tokenId)`，传入参数为房屋编号，这个函数会直接查询所有房屋数组中对应下标的房屋的所有信息并且进行返回。

​	在前端页面中，查询所有挂出房屋后，每个挂出的房屋后面会有一个查询信息的按钮，点击之后便会显示房屋的价格信息。

8. 购买挂出的房屋

​	项目中添加了函数 `buyHouseWithTokens(uint256 tokenId)`，传入的参数为房屋编号。在这个函数中，系统会判断这个房屋是否挂出，并且判断发出购买请求的用户是否为房屋的拥有者以及用户的 ERC20 代币的余额数量是否能够购买这个房屋。通过这些判断之后，系统会自动计算手续费，然后通过 ERC20 合约的 transferFrom 函数分别向房屋持有者和合约部署者转移对应数量的 ERC20 代币，最后转让房屋的拥有权，并且更新 houses 数组中房屋的对应信息。

​	在前端页面中，查询所有挂出房屋后，每个挂出的房屋后面会有一个购买房屋的按钮，点击之后确认便可以调用后端的对应函数购买对应的房子，刷新后便可以通过查看自己的 ERC20 代币余额和拥有的房屋查看交易的结果。

9. 查看自己拥有的ERC20代币数量

​	项目中添加了函数 `getUserTokenBalance()`，在这个函数中会直接使用 ERC20 合约的 balanceOf 函数查询放出请求用户拥有的 ERC20 代币数量，并且进行返回。

​	在前端页面中，有一个查询拥有的 ERC20 代币按钮，用户点击后就可以查看自己拥有的 ERC20 代币数量。

## 项目运行截图

​	**项目启动时 Ganache 的状态**

![image-20241013184402080](photos/image-20241013184402080.png)

![image-20241013184418428](photos/image-20241013184418428.png)

![image-20241013184429719](photos/image-20241013184429719.png)

​	**首次进入时的页面**

![image-20241013184650457](photos/image-20241013184650457.png)

​	**登录用户 5**

![image-20241013184802345](photos/image-20241013184802345.png)

​	**领取3个房子后查看**

![image-20241013184852352](photos/image-20241013184852352.png)

​	此时的 Ganache 中多了一个区块和一笔交易

![image-20241013184956613](photos/image-20241013184956613.png)

![image-20241013185006817](photos/image-20241013185006817.png)

​	**然后兑换10个ERC20代币**

​	这是兑换前的账户

![image-20241013185140449](photos/image-20241013185140449.png)

​	这是兑换后的ERC20代币数量和以太币数量

![image-20241013185254743](photos/image-20241013185254743.png)

​	并且此时 Ganache 中多了一个区块和一笔交易

![image-20241013185437112](photos/image-20241013185437112.png)

![image-20241013185420703](photos/image-20241013185420703.png)

​	**用户5挂出自己编号为1，2的房屋**

![image-20241013185542773](photos/image-20241013185542773.png)

![image-20241013185614095](photos/image-20241013185614095.png)

​	此时查看所有挂出的房子，就可以看到这两个房子

![image-20241013185716131](photos/image-20241013185716131.png)

​	并且 Ganache 中多了2个区块和2笔交易

![image-20241013185741839](photos/image-20241013185741839.png)

![image-20241013185750989](photos/image-20241013185750989.png)

​	**切换到用户4，并且领取3个房屋，兑换10个代币**

![image-20241013185958774](photos/image-20241013185958774.png)

​	此时 Ganache 中多了2个区块和2笔交易

![image-20241013190034616](photos/image-20241013190034616.png)

![image-20241013190020737](photos/image-20241013190020737.png)

​	**在所有挂出的房屋中查看编号为1的房屋的主人**

![image-20241013190252483](photos/image-20241013190252483.png)

​	可以看到正好是用户5的私钥

​	**查看房屋信息**

![image-20241013190432891](photos/image-20241013190432891.png)

​	可以看到编号为1的房屋的价格为3个代币，确实是刚才设置的价格

​	**购买房屋**

​	查看购买房屋前用户2的代币数量（用户2是这个合约的部署者）

![image-20241013190642285](photos/image-20241013190642285.png)

​	这里我先用用户2兑换了10个代币，所以此时 Ganache 中又新增了1个区块和1笔交易

![image-20241013190730760](photos/image-20241013190730760.png)

![image-20241013190740443](photos/image-20241013190740443.png)

​	切换回用户4购买编号为1的房屋

![image-20241013191210422](photos/image-20241013191210422.png)

​	此时再次查询自己的代币数量和拥有房屋

![image-20241013191348841](photos/image-20241013191348841.png)

​	可以看到代币数量少了3个，并且拥有的房屋中多了编号为1的房屋

​	并且 Ganache 中多了2个区块和2笔交易

![image-20241013191559471](photos/image-20241013191559471.png)

![image-20241013191614871](photos/image-20241013191614871.png)

​	此时切换到用户5进行查看

![image-20241013191659313](photos/image-20241013191659313.png)

​	看到代币数量多了3个，并且拥有的房子中少了编号为1的

​	切换到用户2查看

![image-20241013191913168](photos/image-20241013191913168.png)

​	发现用户2的代币数量没有增加，但是经过查看后发现是增加较少而导致的前端的渲染问题，其实手续费还是有的，我的代码中的手续费的计算逻辑是这样的

![image-20241013192057286](photos/image-20241013192057286.png)

​	**再次购买**

​	切换到用户3，获取3个房屋，兑换代币

![image-20241013192334092](photos/image-20241013192334092.png)

​	此时 Ganache 中多了2个区块和2笔交易

![image-20241013192415446](photos/image-20241013192415446.png)

![image-20241013192425539](photos/image-20241013192425539.png)

​	购买编号为2的房屋后

![image-20241013192518872](photos/image-20241013192518872.png)

​	代币少了4个，拥有房屋中多了编号为2的房屋

​	并且 Ganache 中多了2个区块和2笔交易

![image-20241013192611996](photos/image-20241013192611996.png)

![image-20241013192619820](photos/image-20241013192619820.png)

​	查看用户5

![image-20241013192713022](photos/image-20241013192713022.png)

​	代币多了4个，拥有房屋中的编号2消失了，说明交易也成功了

## 参考内容

- 课程的参考Demo见：[DEMOs](https://github.com/LBruyne/blockchain-course-demos)。

- 快速实现 ERC721 和 ERC20：[模版](https://wizard.openzeppelin.com/#erc20)。记得安装相关依赖 ``"@openzeppelin/contracts": "^5.0.0"``。

- 如何实现ETH和ERC20的兑换？ [参考讲解](https://www.wtf.academy/en/docs/solidity-103/DEX/)

- 前端代码搭建时参考 ChatGPT
